// v1 - Demand Gen only script
// template sheet to copy -> https://docs.google.com/spreadsheets/d/1ohhff-XM5eBP0Umto4Fg_kifRxluLqQ-ADzvVkaIn18/copy 


const SHEET_URL = '' // create a copy of the template above first (otherwise a new sheet is created every time)

const CLIENTCODE = '' // this string will be added to your sheet name to make sheet management easier. It doesn't affect the running of the script at all.


// please don't change any code below this line, thanks! ——————————————————————————————————————————————————————————————————————————————



const OTHER_SETTINGS = {
    scriptVersion: 'v1',
    weeklyDays: 366,
    errorCol: 12,
    comingFrom: 'single',
    mccTimezone: AdsApp.currentAccount().getTimeZone(),
    defaultSettings: {
        numberOfDays: 30
    },
    urls: {
        clientNew: typeof SHEET_URL !== 'undefined' ? SHEET_URL : '',
        template: 'https://docs.google.com/spreadsheets/d/1ohhff-XM5eBP0Umto4Fg_kifRxluLqQ-ADzvVkaIn18/', // DG Template
    },
};

function main() {

    let sheetUrl = typeof SHEET_URL !== 'undefined' ? SHEET_URL : '';
    let clientCode = CLIENTCODE;
    let mcc = OTHER_SETTINGS;

    Logger.log('Starting the Demand Gen Insights script.');
    let { dgSS, s, start, ident } = configureScript(sheetUrl, clientCode, mcc);
    if (!dgSS) {
        Logger.log('Could not configure script. Exiting.');
        return;
    }
    s.timezone = AdsApp.currentAccount().getTimeZone();
    let { mainDateRange, fromDate, toDate } = prepareDateRange(s);
    let elements = defineElements(s);

    processDG(dgSS, s, ident, mcc, mainDateRange, elements, fromDate, toDate);

    // log(dgSS, start, s, ident); // hidden until log tab created

    // MCC snippet here

} // end func

function processDG(dgSS, s, ident, mcc, mainDateRange, elements, fromDate, toDate) {

    Logger.log('Starting Demand Gen processing.');

    if (!dgSS) {
        Logger.log('Could not open or create the DG sheet. Exiting DG processing.');
        return;
    }

    try {
        const formattedFromDate = Utilities.formatDate(fromDate, s.timezone, "dd/MM/yyyy");
        const formattedToDate = Utilities.formatDate(toDate, s.timezone, "dd/MM/yyyy");
        const dateRangeValue = `Date Range d/m/y   ${formattedFromDate} - ${formattedToDate}`;

        let range = dgSS.getRangeByName('chartDateRange');
        if (range) {
            range.setValue(dateRangeValue);
        } else {
            Logger.log("Named range 'chartDateRange' not found in DG sheet. It will not be created.");
        }
    } catch (e) {
        Logger.log(`Could not set chartDateRange in DG sheet: ${e.message}`);
    }


    let queries = {};
    const e = elements;
    const date = mainDateRange;
    queries.dgCampaignQuery = 'SELECT ' + [e.segDate, e.campName, e.campId, e.networkType, e.impr, e.clicks, e.cost, e.conv, e.value, e.views, e.cpv].join(',') +
        ' FROM campaign WHERE ' + date + e.dgOnly + e.campLike + e.impr0 + e.order;
    queries.dgAdsQuery = 'SELECT ' + [e.dgAdId, e.dgAdName, e.dgAdType, e.dgFinalUrls, e.dgAdStatus, e.dgAdGroupName, e.dgAdGroupId, e.campName, e.campId, e.impr, e.clicks, e.cost, e.conv, e.value].join(',') +
        ' FROM ad_group_ad WHERE ad_group_ad.ad.type IN ("DEMAND_GEN_PRODUCT_AD", "DEMAND_GEN_VIDEO_RESPONSIVE_AD", "DEMAND_GEN_CAROUSEL_AD", "DEMAND_GEN_MULTI_ASSET_AD") AND ' + date + e.impr0;
    queries.dgAssetsQuery = 'SELECT ' + [e.dgAssetId, e.dgAssetName, e.assetSource, e.dgAssetType, e.dgImageFileSize, e.dgImageMimeType, e.dgImageUrl, e.dgImageWidth, e.dgImageHeight, e.dgTextContent, e.dgYouTubeId, e.dgYouTubeTitle, e.dgCTA, e.dgAdId, e.dgAdName, e.dgAdType, e.dgAdGroupName, e.campName, e.impr, e.clicks, e.cost, e.conv, e.value].join(',') +
        ' FROM ad_group_ad_asset_view WHERE ad_group_ad.ad.type IN ("DEMAND_GEN_PRODUCT_AD", "DEMAND_GEN_VIDEO_RESPONSIVE_AD", "DEMAND_GEN_CAROUSEL_AD", "DEMAND_GEN_MULTI_ASSET_AD") AND ' + date + e.impr0;

    let dgCampaignData = fetchData(queries.dgCampaignQuery);
    let dgAdsData = fetchData(queries.dgAdsQuery);
    let dgAssetsData = fetchData(queries.dgAssetsQuery);

    // Find and set top DG campaign by cost
    let topDgCampaignName = '';
    if (dgCampaignData && dgCampaignData.length > 0) {
        const topCampaign = dgCampaignData.reduce((max, row) => {
            const maxCost = max ? (parseInt(max['metrics.costMicros']) || 0) : 0;
            const currentCost = parseInt(row['metrics.costMicros']) || 0;
            return currentCost > maxCost ? row : max;
        }, null);
        if (topCampaign) {
            topDgCampaignName = topCampaign['campaign.name'];
        }
    }

    if (topDgCampaignName) {
        try {
            const range = dgSS.getRangeByName('selectedCampaign');
            if (range) {
                range.setValue(topDgCampaignName);
                Logger.log(`Set 'selectedCampaign' in DG sheet to top campaign: ${topDgCampaignName}`);
            } else {
                Logger.log("Named range 'selectedCampaign' not found in DG sheet. It will not be created.");
            }
        } catch (e) {
            Logger.log(`Could not set 'selectedCampaign' in DG sheet: ${e.message}`);
        }
    }

    let dDgSummary = processDgSummary(dgCampaignData);
    let dDgChartData = processDgChartData(dgCampaignData);
    let dDgAds = processDgAds(dgAdsData);
    let dDgAssets = processDgAssets(dgAssetsData);
    let dAggregatedDgAssets = processAggregatedDgAssets(dgAssetsData);

    // Asset Fatigue Analysis
    let assetIds = dAggregatedDgAssets.slice(1).map(row => row[0]); // Get asset IDs, skip header
    let dAssetFatigue = processAssetFatigue(assetIds, elements, s);

    // Create a map of Asset ID -> Trend from the fatigue data
    const trendMap = new Map(dAssetFatigue.slice(1).map(row => [row[0], row[8]])); // Asset ID is at index 0, Trend is at index 8

    // Add Trend column to the aggregated assets data
    if (dAggregatedDgAssets.length > 1 && trendMap.size > 0) {
        // Add header - between CPA and AssetType
        dAggregatedDgAssets[0].splice(14, 0, 'Trend');

        // Add trend data to each row
        for (let i = 1; i < dAggregatedDgAssets.length; i++) {
            const assetId = dAggregatedDgAssets[i][0];
            const trend = trendMap.get(assetId) || 'Insufficient Data';
            dAggregatedDgAssets[i].splice(14, 0, trend);
        }
    }

    outputAndFormatDgSheet(dgSS, 'dgSummary', dDgSummary);
    outputAndFormatDgSheet(dgSS, 'dgChartData', dDgChartData);
    outputAndFormatDgSheet(dgSS, 'dgAds', dDgAds);
    outputAndFormatDgSheet(dgSS, 'dgAssets', dDgAssets);
    outputAndFormatDgSheet(dgSS, 'asset', dAggregatedDgAssets);
    outputAndFormatDgSheet(dgSS, 'assetFatigue', dAssetFatigue);

    Logger.log('Finished DG Processing.');

    function outputAndFormatDgSheet(ss, sheetName, data) {
        let sheet = ss.getSheetByName(sheetName) || ss.insertSheet(sheetName);

        if (!data || data.length === 0) {
            Logger.log('No data to write to ' + sheetName);
            sheet.clearContents();
            return;
        }

        sheet.clearContents();

        let range = sheet.getRange(1, 1, data.length, data[0].length);
        range.setValues(data);

        const numberFormats = {
            // 0 dp
            'Impr': '#,##0',
            'Impr.': '#,##0',
            'Clicks': '#,##0',
            'Views': '#,##0',
            // 1 dp
            'ROAS': '#,##0.0',
            // 2 dp
            'Cost': '#,##0.00',
            'Value': '#,##0.00',
            'AOV': '#,##0.00',
            'Conv': '#,##0.0',
            'Conv.': '#,##0.0',
            'CPA': '#,##0.00',
            'Avg. CPV': '#,##0.00',
            'AvgCPV': '#,##0.00',
            'Camp Cost': '#,##0.00',
            'Camp Conv': '#,##0.0',
            'Camp Value': '#,##0.00',
            'Youtube Cost': '#,##0.00',
            'Youtube Conv': '#,##0.0',
            'Youtube Value': '#,##0.00',
            'Discover Cost': '#,##0.00',
            'Discover Conv': '#,##0.0',
            'Discover Value': '#,##0.00',
            'Gmail Cost': '#,##0.00',
            'Gmail Conv': '#,##0.00',
            'Gmail Value': '#,##0.00',
            // % 2dp
            'CTR': '0.00%',
            'CvR': '0.00%',
            'CVR': '0.00%',
            'YouTube Cost %': '0%',
            'YouTube Conv %': '0%',
            'YouTube Value %': '0%',
            'Discover Cost %': '0%',
            'Discover Conv %': '0%',
            'Discover Value %': '0%',
            'Gmail Cost %': '0%',
            'Gmail Conv %': '0%',
            'Gmail Value %': '0%',
            // assetFatigue formats
            'CTR Week 1': '0.00%',
            'CTR Week 2': '0.00%',
            'CTR Week 3': '0.00%',
            'CTR Week 4': '0.00%',
            'CTR Week 5': '0.00%',
            'CTR Week 6': '0.00%',
        };

        const headers = data[0];
        const rowFormats = headers.map(h => numberFormats[h] || '@');
        const formatMatrix = [];
        for (let i = 1; i < data.length; i++) {
            formatMatrix.push(rowFormats);
        }

        if (formatMatrix.length > 0) {
            sheet.getRange(2, 1, formatMatrix.length, formatMatrix[0].length).setNumberFormats(formatMatrix);
        }
    }

    function processAggregatedDgAssets(data) {
        if (!data || data.length === 0) return [
            ['No aggregated DG Asset data available']
        ];

        const aggregated = {};

        data.forEach(row => {
            const assetId = row['asset.id'];
            if (!assetId) return;

            if (!aggregated[assetId]) {
                let fileTitle = '';
                let urlId = '';
                switch (row['asset.type']) {
                    case 'TEXT':
                        fileTitle = row['asset.textAsset.text'];
                        urlId = assetId;
                        break;
                    case 'YOUTUBE_VIDEO':
                        fileTitle = row['asset.youtubeVideoAsset.youtubeVideoTitle'];
                        urlId = row['asset.youtubeVideoAsset.youtubeVideoId'] ? `https://www.youtube.com/watch?v=${row['asset.youtubeVideoAsset.youtubeVideoId']}` : '';
                        break;
                    case 'IMAGE':
                        fileTitle = row['asset.name'];
                        urlId = row['asset.imageAsset.fullSize.url'] || '';
                        break;
                    case 'CALL_TO_ACTION':
                        fileTitle = row['asset.callToActionAsset.callToAction'];
                        urlId = assetId;
                        break;
                }

                aggregated[assetId] = {
                    'ID': assetId,
                    'Source': row['asset.source'],
                    'File/Title': fileTitle,
                    'URL/ID': urlId,
                    'Asset Type': row['asset.type'],
                    'Impr': 0,
                    'Clicks': 0,
                    'Cost': 0,
                    'Conv': 0,
                    'Value': 0
                };
            }

            aggregated[assetId]['Impr'] += parseInt(row['metrics.impressions']) || 0;
            aggregated[assetId]['Clicks'] += parseInt(row['metrics.clicks']) || 0;
            aggregated[assetId]['Cost'] += (parseInt(row['metrics.costMicros']) || 0) / 1e6;
            aggregated[assetId]['Conv'] += parseFloat(row['metrics.conversions']) || 0;
            aggregated[assetId]['Value'] += parseFloat(row['metrics.conversionsValue']) || 0;
        });

        const headers = ['ID', 'Source', 'File/Title', 'URL/ID', 'Impr', 'Clicks', 'Cost', 'Conv', 'Value', 'CTR', 'CVR', 'AOV', 'ROAS', 'CPA', 'AssetType'];

        const rows = Object.values(aggregated).map(agg => {
            const impr = agg['Impr'];
            const clicks = agg['Clicks'];
            const cost = agg['Cost'];
            const conv = agg['Conv'];
            const value = agg['Value'];

            const ctr = impr > 0 ? clicks / impr : 0;
            const cvr = clicks > 0 ? conv / clicks : 0;
            const aov = conv > 0 ? value / conv : 0;
            const roas = cost > 0 ? value / cost : 0;
            const cpa = conv > 0 ? cost / conv : 0;

            return [
                agg['ID'], agg['Source'], agg['File/Title'], agg['URL/ID'],
                impr, clicks, cost, conv, value,
                ctr, cvr, aov, roas, cpa,
                agg['Asset Type']
            ];
        });

        rows.sort((a, b) => b[4] - a[4]); // Sort by Impr descending

        return [headers, ...rows];
    }

    function processNetworkBreakdown(data, groupByDate) {
        if (!data || data.length === 0) return [
            ['No DG network breakdown data available']
        ];
        const aggregated = {};
        data.forEach(row => {
            const campaignName = row['campaign.name'];
            const date = row['segments.date'];
            const key = groupByDate ? `${date}_${campaignName}` : campaignName;

            if (!aggregated[key]) {
                aggregated[key] = {
                    'Date': groupByDate ? date : '',
                    'Campaign Name': campaignName,
                    'Camp Cost': 0,
                    'Camp Conv': 0,
                    'Camp Value': 0,
                    'Youtube Cost': 0,
                    'Youtube Conv': 0,
                    'Youtube Value': 0,
                    'Discover Cost': 0,
                    'Discover Conv': 0,
                    'Discover Value': 0,
                    'Gmail Cost': 0,
                    'Gmail Conv': 0,
                    'Gmail Value': 0
                };
            }

            const cost = (row['metrics.costMicros'] || 0) / 1e6;
            const conv = parseFloat(row['metrics.conversions']) || 0;
            const value = parseFloat(row['metrics.conversionsValue']) || 0;
            const network = row['segments.adNetworkType'];

            aggregated[key]['Camp Cost'] += cost;
            aggregated[key]['Camp Conv'] += conv;
            aggregated[key]['Camp Value'] += value;

            if (network === 'YOUTUBE') {
                aggregated[key]['Youtube Cost'] += cost;
                aggregated[key]['Youtube Conv'] += conv;
                aggregated[key]['Youtube Value'] += value;
            } else if (network === 'DISCOVER') {
                aggregated[key]['Discover Cost'] += cost;
                aggregated[key]['Discover Conv'] += conv;
                aggregated[key]['Discover Value'] += value;
            } else if (network === 'GMAIL') {
                aggregated[key]['Gmail Cost'] += cost;
                aggregated[key]['Gmail Conv'] += conv;
                aggregated[key]['Gmail Value'] += value;
            }
        });

        const headers = [
            'Campaign Name', 'Camp Cost', 'Camp Conv', 'Camp Value',
            'Youtube Cost', 'Youtube Conv', 'Youtube Value',
            'Discover Cost', 'Discover Conv', 'Discover Value',
            'Gmail Cost', 'Gmail Conv', 'Gmail Value',
            'YouTube Cost %', 'Discover Cost %', 'Gmail Cost %',
            'YouTube Conv %', 'Discover Conv %', 'Gmail Conv %',
            'YouTube Value %', 'Discover Value %', 'Gmail Value %',
            'Youtube Cost', 'Discover Cost', 'Gmail Cost',
            'Youtube Conv', 'Discover Conv', 'Gmail Conv',
            'Youtube Value', 'Discover Value', 'Gmail Value'
        ];

        if (groupByDate) {
            headers.unshift('Date');
        }

        const rows = Object.values(aggregated).map(agg => {
            const campCost = agg['Camp Cost'];
            const campConv = agg['Camp Conv'];
            const campValue = agg['Camp Value'];
            let row = [
                agg['Campaign Name'],
                agg['Camp Cost'], agg['Camp Conv'], agg['Camp Value'],
                // By Network type
                agg['Youtube Cost'], agg['Youtube Conv'], agg['Youtube Value'],
                agg['Discover Cost'], agg['Discover Conv'], agg['Discover Value'],
                agg['Gmail Cost'], agg['Gmail Conv'], agg['Gmail Value'],
                // Cost Percentages
                campCost > 0 ? agg['Youtube Cost'] / campCost : 0,
                campCost > 0 ? agg['Discover Cost'] / campCost : 0,
                campCost > 0 ? agg['Gmail Cost'] / campCost : 0,
                // Conversion Percentages
                campConv > 0 ? agg['Youtube Conv'] / campConv : 0,
                campConv > 0 ? agg['Discover Conv'] / campConv : 0,
                campConv > 0 ? agg['Gmail Conv'] / campConv : 0,
                // Value Percentages
                campValue > 0 ? agg['Youtube Value'] / campValue : 0,
                campValue > 0 ? agg['Discover Value'] / campValue : 0,
                campValue > 0 ? agg['Gmail Value'] / campValue : 0,
                // Repeat for totals in different grouping to make it easy to chart
                agg['Youtube Cost'], agg['Discover Cost'], agg['Gmail Cost'],
                agg['Youtube Conv'], agg['Discover Conv'], agg['Gmail Conv'],
                agg['Youtube Value'], agg['Discover Value'], agg['Gmail Value']
            ];
            if (groupByDate) {
                row.unshift(agg['Date']);
            }
            return row;
        });

        if (groupByDate) {
            // dgSummary: Sort by Date asc, then Camp Cost desc
            rows.sort((a, b) => {
                if (a[0] > b[0]) return 1;
                if (a[0] < b[0]) return -1;
                return b[2] - a[2];
            });
        } else {
            // dgChartData: Sort by Camp Cost desc
            rows.sort((a, b) => b[1] - a[1]);
        }

        return [headers, ...rows];
    }

    function processDgSummary(data) {
        return processNetworkBreakdown(data, true);
    }

    function processDgChartData(data) {
        return processNetworkBreakdown(data, false);
    }

    function processDgAds(data) {
        if (!data || data.length === 0) return [
            ['No Demand Gen Ads data available']
        ];
        const headers = ['Campaign', 'AdGroup', 'AdName', 'AdID', 'AdType', 'Status', 'Impr', 'Clicks', 'Cost', 'Conv.', 'Value', 'CTR', 'CvR', 'CPA', 'ROAS'];
        const rows = data.map(row => {
            const cost = (row['metrics.costMicros'] || 0) / 1e6;
            const clicks = row['metrics.clicks'] || 0;
            const impressions = row['metrics.impressions'] || 0;
            const conversions = row['metrics.conversions'] || 0;
            const value = row['metrics.conversionsValue'] || 0;
            return [
                row['campaign.name'],
                row['adGroup.name'],
                row['adGroupAd.ad.name'],
                row['adGroupAd.ad.id'],
                row['adGroupAd.ad.type'],
                row['adGroupAd.status'],
                impressions,
                clicks,
                cost,
                conversions,
                value,
                impressions > 0 ? clicks / impressions : 0,
                clicks > 0 ? conversions / clicks : 0,
                conversions > 0 ? cost / conversions : 0,
                cost > 0 ? value / cost : 0
            ];
        });
        return [headers, ...rows];
    }

    function processDgAssets(data) {
        if (!data || data.length === 0) return [
            ['No Demand Gen Asset data available']
        ];
        const headers = ['Campaign', 'AdGroup', 'AdName', 'AdID', 'AssetName', 'AssetID', 'AssetType', 'Content', 'Impr', 'Clicks', 'Cost', 'Conv.', 'Value', 'CTR', 'CvR', 'CPA', 'ROAS'];
        const rows = data.map(row => {
            const cost = (row['metrics.costMicros'] || 0) / 1e6;
            const clicks = row['metrics.clicks'] || 0;
            const impressions = row['metrics.impressions'] || 0;
            const conversions = row['metrics.conversions'] || 0;
            const value = row['metrics.conversionsValue'] || 0;
            let content = '';
            switch (row['asset.type']) {
                case 'TEXT':
                    content = row['asset.textAsset.text'];
                    break;
                case 'YOUTUBE_VIDEO':
                    content = row['asset.youtubeVideoAsset.youtubeVideoId'] ? `https://www.youtube.com/watch?v=${row['asset.youtubeVideoAsset.youtubeVideoId']}` : '';
                    break;
                case 'IMAGE':
                    content = row['asset.imageAsset.fullSize.url'] || row['asset.name'];
                    break;
                case 'CALL_TO_ACTION':
                    content = row['asset.callToActionAsset.callToAction'];
                    break;
            }
            return [
                row['campaign.name'],
                row['adGroup.name'],
                row['adGroupAd.ad.name'],
                row['adGroupAd.ad.id'],
                row['asset.name'],
                row['asset.id'],
                row['asset.type'],
                content,
                impressions,
                clicks,
                cost,
                conversions,
                value,
                impressions > 0 ? clicks / impressions : 0,
                clicks > 0 ? conversions / clicks : 0,
                conversions > 0 ? cost / conversions : 0,
                cost > 0 ? value / cost : 0
            ];
        });
        return [headers, ...rows];
    }

    function processAssetFatigue(assetIds, e, s) {
        if (!assetIds || assetIds.length === 0) {
            return [
                ['No assets to analyze for fatigue.']
            ];
        }

        // 1. Calculate date range for the last 6 full weeks (Mon-Sun)
        let today = new Date();
        let dayOfWeek = today.getDay(); // Sunday = 0, Monday = 1, etc.
        let daysToLastSunday = dayOfWeek === 0 ? 7 : dayOfWeek;
        let endDate = new Date(today);
        endDate.setDate(today.getDate() - daysToLastSunday);

        let startDate = new Date(endDate);
        startDate.setDate(endDate.getDate() - 41); // 6 weeks total (6*7 - 1)

        const fStartDate = Utilities.formatDate(startDate, s.timezone, 'yyyy-MM-dd');
        const fEndDate = Utilities.formatDate(endDate, s.timezone, 'yyyy-MM-dd');
        const dateRange = `segments.date BETWEEN '${fStartDate}' AND '${fEndDate}'`;

        // 2. Build and run the query
        // Chunk asset IDs to avoid query length limits
        const chunkSize = 1000;
        let allWeeklyData = [];
        for (let i = 0; i < assetIds.length; i += chunkSize) {
            const assetIdChunk = assetIds.slice(i, i + chunkSize);
            const assetIdFilter = `asset.id IN (${assetIdChunk.map(id => `'${id}'`).join(',')})`;
            const weeklyQuery = `
          SELECT asset.id, asset.name, asset.youtube_video_asset.youtube_video_title, asset.text_asset.text, segments.week, metrics.clicks, metrics.impressions
          FROM ad_group_ad_asset_view
          WHERE ${assetIdFilter} AND ${dateRange} AND ad_group_ad.ad.type IN ("DEMAND_GEN_PRODUCT_AD", "DEMAND_GEN_VIDEO_RESPONSIVE_AD", "DEMAND_GEN_CAROUSEL_AD", "DEMAND_GEN_MULTI_ASSET_AD")`;
            let weeklyData = fetchData(weeklyQuery);
            allWeeklyData = allWeeklyData.concat(weeklyData);
        }


        if (allWeeklyData.length === 0) {
            return [
                ['No weekly performance data found for these assets in the last 6 weeks.']
            ];
        }

        // 3. Process the data
        const assetData = {};
        allWeeklyData.forEach(row => {
            const id = row['asset.id'];
            if (!assetData[id]) {
                assetData[id] = {
                    title: row['asset.name'] || row['asset.youtubeVideoAsset.youtubeVideoTitle'] || row['asset.textAsset.text'] || `Asset ${id}`,
                    weeks: {}
                };
            }
            assetData[id].weeks[row['segments.week']] = {
                clicks: parseInt(row['metrics.clicks']) || 0,
                impressions: parseInt(row['metrics.impressions']) || 0,
            };
        });

        // 4. Get the last 6 week start dates for headers
        const weekDates = [];
        let lastMonday = new Date(endDate);
        lastMonday.setDate(endDate.getDate() - 6); // Find the Monday of the last full week
        for (let i = 5; i >= 0; i--) {
            let weekStart = new Date(lastMonday);
            weekStart.setDate(lastMonday.getDate() - (i * 7));
            weekDates.push(Utilities.formatDate(weekStart, 'UTC', 'yyyy-MM-dd'));
        }

        const headers = ['Asset ID', 'File/Title', 'CTR Week 1', 'CTR Week 2', 'CTR Week 3', 'CTR Week 4', 'CTR Week 5', 'CTR Week 6', 'Trend'];
        const results = [];

        // 5. Analyze each asset
        for (const id in assetData) {
            const asset = assetData[id];
            const ctrs = weekDates.map(week => {
                const weekData = asset.weeks[week];
                if (weekData && weekData.impressions > 0) {
                    return weekData.clicks / weekData.impressions;
                }
                return null; // Use null for weeks with no data
            });

            const validCtrs = ctrs.filter(ctr => ctr !== null);
            let trend = 'Insufficient Data';

            if (validCtrs.length >= 3) { // Need at least 3 data points for a trend
                const trendAnalysis = linearRegression(validCtrs.map((ctr, i) => ({
                    x: i,
                    y: ctr
                })));
                trend = getTrendCategory(trendAnalysis.slope, trendAnalysis.r2);
            }

            const formattedCtrs = ctrs.map(ctr => ctr === null ? 'N/A' : ctr);
            results.push([id, asset.title, ...formattedCtrs, trend]);
        }

        return [headers, ...results];
    }

    function linearRegression(data) {
        const n = data.length;
        let sum_x = 0,
            sum_y = 0,
            sum_xy = 0,
            sum_xx = 0;

        for (let i = 0; i < n; i++) {
            sum_x += data[i].x;
            sum_y += data[i].y;
            sum_xy += (data[i].x * data[i].y);
            sum_xx += (data[i].x * data[i].x);
        }

        const slope = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x);
        const intercept = (sum_y - slope * sum_x) / n;

        // Calculate R-squared
        let ss_tot = 0,
            ss_res = 0;
        const y_mean = sum_y / n;
        for (let i = 0; i < n; i++) {
            ss_tot += Math.pow(data[i].y - y_mean, 2);
            ss_res += Math.pow(data[i].y - (slope * data[i].x + intercept), 2);
        }
        const r2 = (ss_tot === 0) ? 1 : 1 - (ss_res / ss_tot);

        return {
            slope,
            intercept,
            r2
        };
    }

    function getTrendCategory(slope, r2) {
        const R2_THRESHOLD_HIGH = 0.65;
        const R2_THRESHOLD_LOW = 0.3;
        const SLOPE_THRESHOLD_HIGH = 0.002; // 0.2% CTR change per week
        const SLOPE_THRESHOLD_LOW = 0.0005; // 0.05% CTR change per week

        if (Math.abs(slope) < SLOPE_THRESHOLD_LOW) return 'Sideways';

        const direction = slope > 0 ? 'Up' : 'Down';
        const magnitude = Math.abs(slope) > SLOPE_THRESHOLD_HIGH ? 'Clear' : 'Slight';

        if (r2 > R2_THRESHOLD_HIGH) {
            return `${magnitude} Trend ${direction}`;
        } else if (r2 < R2_THRESHOLD_LOW) {
            return 'Volatile';
        } else {
            return `Potential Trend ${direction}`;
        }
    }
}

function configureScript(sheetUrl, clientCode, mcc) {
    let start = new Date();
    let s;
    let accountName = AdsApp.currentAccount().getName();
    let ident = clientCode || accountName;
    if (mcc.comingFrom === 'single') {
        let accDate = new Date().toLocaleString('en-US', {
            timeZone: mcc.mccTimezone
        });
        mcc.mccDay = new Date(accDate).getDay();
    }

    let dgSS;
    if (sheetUrl) {
        // A sheet URL is provided. We assume it's configured.
        Logger.log('Using provided sheet URL: ' + sheetUrl);
        dgSS = safeOpenAndShareSpreadsheet(sheetUrl);
    } else {
        // No sheet URL. This is a first run or a reset.
        Logger.log('No sheet URL provided. Creating a new sheet from template.');
        dgSS = safeOpenAndShareSpreadsheet(mcc.urls.template, true, `${ident} ${mcc.scriptVersion} - Demand Gen Insights - (c) MikeRhodes.com.au `);
        Logger.log('****\nCreated new Demand Gen Insights sheet for: ' + ident + '\nURL is ' + (dgSS ? dgSS.getUrl() : 'ERROR_CREATING_SHEET') +
            '\nRemember to add this URL to the top of your script before next run.\n****');
    }

    if (!dgSS) {
        Logger.log('Could not open or create spreadsheet. Exiting.');
        return {};
    }

    // Now, determine the settings based on whether a URL was originally provided.
    if (sheetUrl) {
        // If a URL was given, read all settings from that sheet.
        Logger.log('Reading settings from the provided sheet.');
        s = updateVariablesFromSheet(dgSS, mcc.scriptVersion, mcc.defaultSettings);
    } else {
        // If no URL was given, use the hardcoded defaults for the date range.
        // The new sheet is created, but we don't read settings from it on this first run.
        Logger.log(`Using default date range of ${mcc.defaultSettings.numberOfDays} days for this first run.`);
        s = { ...mcc.defaultSettings
        };
    }

    s.ident = ident;

    // logSettings(s, dgSS); // hidden until log tab created
    // checkVersion(mcc.scriptVersion, s.sheetVersion, dgSS); // hidden until script & sheet versions updated and named ranges created

    return {
        dgSS,
        s,
        start,
        ident
    };
}

function logSettings(s, ss) {
    s = s || {};
    let logSettings = {
        ...s
    };
    logSettings.ssUrl = ss.getUrl();
    Logger.log('Settings: ' + JSON.stringify(logSettings, null, 2));
}

function updateVariablesFromSheet(ss, version, defaultSettings) {

    let updatedSettings = {
        ...defaultSettings
    };

    const allRangeNames = [
        'numberOfDays', 'fromDate', 'toDate', 'sheetVersion'
    ];

    try {
        allRangeNames.forEach(rangeName => {
            try {
                const range = ss.getRangeByName(rangeName);
                if (range) {
                    let value = range.getDisplayValue().trim();
                    if (value !== '') {
                        if (['fromDate', 'toDate'].includes(rangeName)) {
                            updatedSettings[rangeName] = /^\d{1,2}\/\d{1,2}\/\d{4}$/.test(value) ? value : updatedSettings[rangeName];
                        } else if (['numberOfDays'].includes(rangeName)) {
                            updatedSettings[rangeName] = isNaN(value) ? updatedSettings[rangeName] : Number(value);
                        } else {
                            updatedSettings[rangeName] = value;
                        }
                    }
                }
            } catch (e) {
                console.warn(`Named range ${rangeName} not found or error occurred. Using default value.`);
            }
        });
        return updatedSettings;

    } catch (e) {
        console.error("Error in 'updateVariablesFromSheet': ", e);
        return updatedSettings;
    }
}

function prepareDateRange(s) {
    let fromDateObj, toDateObj;

    // Priority 1: Check for specific from/to dates from the sheet
    const hasSpecificDates = s.fromDate && s.toDate;

    if (hasSpecificDates) {
        Logger.log(`Using specific date range from sheet: ${s.fromDate} - ${s.toDate}`);
        try {
            const fromParts = s.fromDate.split('/');
            const toParts = s.toDate.split('/');
            fromDateObj = new Date(parseInt(fromParts[2], 10), parseInt(fromParts[1], 10) - 1, parseInt(fromParts[0], 10));
            toDateObj = new Date(parseInt(toParts[2], 10), parseInt(toParts[1], 10) - 1, parseInt(toParts[0], 10));

            // A simple check to see if the dates are valid
            if (isNaN(fromDateObj.getTime()) || isNaN(toDateObj.getTime())) {
                throw new Error("Invalid date format in sheet. Please use d/m/yyyy.");
            }
        } catch (e) {
            Logger.log(`Error parsing dates from sheet: ${e.message}. Falling back to numberOfDays logic.`);
            // Fallback to numberOfDays logic if parsing fails
            const today = new Date();
            toDateObj = new Date();
            toDateObj.setDate(today.getDate() - 1); // Yesterday
            fromDateObj = new Date();
            fromDateObj.setDate(today.getDate() - s.numberOfDays);
        }
    } else {
        // Priority 2: Use numberOfDays from the sheet (if read) or the script's default value
        Logger.log(`Using 'numberOfDays' for date range: ${s.numberOfDays} days.`);
        const today = new Date();
        toDateObj = new Date();
        toDateObj.setDate(today.getDate() - 1); // Yesterday
        fromDateObj = new Date();
        fromDateObj.setDate(today.getDate() - s.numberOfDays);
    }

    const fFromDate = Utilities.formatDate(fromDateObj, s.timezone, 'yyyy-MM-dd');
    const fToDate = Utilities.formatDate(toDateObj, s.timezone, 'yyyy-MM-dd');

    const dateRangeQueryString = `segments.date BETWEEN "${fFromDate}" AND "${fToDate}"`;

    return {
        mainDateRange: dateRangeQueryString,
        dateRangeString: dateRangeQueryString,
        fromDate: fromDateObj,
        toDate: toDateObj
    };
}

function defineElements(s) {
    return {
        impr: ' metrics.impressions ', // metrics
        clicks: ' metrics.clicks ',
        cost: ' metrics.cost_micros ',
        engage: ' metrics.engagements ',
        inter: ' metrics.interactions ',
        conv: ' metrics.conversions ',
        value: ' metrics.conversions_value ',
        allConv: ' metrics.all_conversions ',
        allValue: ' metrics.all_conversions_value ',
        views: ' metrics.video_views ',
        cpv: ' metrics.average_cpv ',
        eventTypes: ' metrics.interaction_event_types ',
        segDate: ' segments.date ', // segments
        prodTitle: ' segments.product_title ',
        prodID: ' segments.product_item_id ',
        aIdCamp: ' segments.asset_interaction_target.asset ',
        interAsset: ' segments.asset_interaction_target.interaction_on_this_asset ',
        campName: ' campaign.name ', // campaign
        campId: ' campaign.id ',
        chType: ' campaign.advertising_channel_type ',
        campUrlOptOut: ' campaign.url_expansion_opt_out ',
        lpResName: ' landing_page_view.resource_name ', // landing page
        lpUnexpUrl: ' landing_page_view.unexpanded_final_url ',
        aIdAsset: ' asset.resource_name ', // asset
        aId: ' asset.id ',
        assetSource: ' asset.source ',
        assetName: ' asset.name ',
        assetText: ' asset.text_asset.text ',
        adUrl: ' asset.image_asset.full_size.url ',
        imgHeight: ' asset.image_asset.full_size.height_pixels ',
        imgWidth: ' asset.image_asset.full_size.width_pixels ',
        imgMime: ' asset.image_asset.mime_type ',
        ytTitle: ' asset.youtube_video_asset.youtube_video_title ',
        ytId: ' asset.youtube_video_asset.youtube_video_id ',
        agId: ' asset_group.id ', // asset group
        assetFtype: ' asset_group_asset.field_type ',
        adPmaxPerf: ' asset_group_asset.performance_label ',
        agStrength: ' asset_group.ad_strength ',
        agStatus: ' asset_group.status ',
        agPrimary: ' asset_group.primary_status ',
        asgName: ' asset_group.name ',
        lgType: ' asset_group_listing_group_filter.type ',
        placement: ' detail_placement_view.group_placement_target_url ', // placement
        placeType: ' detail_placement_view.placement_type ',
        chgDateTime: ' change_event.change_date_time ', // change event
        chgResType: ' change_event.change_resource_type ',
        chgFields: ' change_event.changed_fields ',
        clientTyp: ' change_event.client_type ',
        feed: ' change_event.feed ',
        feedItm: ' change_event.feed_item ',
        newRes: ' change_event.new_resource ',
        oldRes: ' change_event.old_resource ',
        resChgOp: ' change_event.resource_change_operation ',
        resName: ' change_event.resource_name ',
        userEmail: ' change_event.user_email ',

        // New elements for geo performance
        geoViewName: ' geographic_view.resource_name ',
        geoLocationType: ' geographic_view.location_type ',
        geoCountryId: ' geographic_view.country_criterion_id ',
        geoTargetCity: ' segments.geo_target_city ',
        geoTargetRegion: ' segments.geo_target_region ',
        geoTargetState: ' segments.geo_target_state ',
        geoTargetCanton: ' segments.geo_target_canton ',
        geoTargetProvince: ' segments.geo_target_province ',
        geoTargetCounty: ' segments.geo_target_county ',
        geoTargetDistrict: ' segments.geo_target_district ',
        geoTargetTypePos: ' campaign.geo_target_type_setting.positive_geo_target_type ',
        geoTargetTypeNeg: ' campaign.geo_target_type_setting.negative_geo_target_type ',

        // New elements for placements
        pmaxPlacementName: ' performance_max_placement_view.display_name ',
        pmaxPlacement: ' performance_max_placement_view.placement ',
        pmaxPlacementType: ' performance_max_placement_view.placement_type ',
        pmaxPlacementResource: ' performance_max_placement_view.resource_name ',
        pmaxPlacementUrl: ' performance_max_placement_view.target_url ',

        // Demand Gen specific elements
        dgAdId: ' ad_group_ad.ad.id ',
        dgAdName: ' ad_group_ad.ad.name ',
        dgAdType: ' ad_group_ad.ad.type ',
        dgAdStatus: ' ad_group_ad.status ',
        dgAdGroupName: ' ad_group.name ',
        dgAdGroupId: ' ad_group.id ',
        dgFinalUrls: ' ad_group_ad.ad.final_urls ',
        dgAssetId: ' asset.id ',
        dgAssetName: ' asset.name ',
        dgAssetType: ' asset.type ',
        dgImageFileSize: ' asset.image_asset.file_size ',
        dgImageMimeType: ' asset.image_asset.mime_type ',
        dgImageUrl: ' asset.image_asset.full_size.url ',
        dgImageWidth: ' asset.image_asset.full_size.width_pixels ',
        dgImageHeight: ' asset.image_asset.full_size.height_pixels ',
        dgTextContent: ' asset.text_asset.text ',
        dgYouTubeId: ' asset.youtube_video_asset.youtube_video_id ',
        dgYouTubeTitle: ' asset.youtube_video_asset.youtube_video_title ',
        dgCTA: ' asset.call_to_action_asset.call_to_action ',

        // Shopping product elements
        shoppingProductId: ' shopping_product.item_id ',
        shoppingProductTitle: ' shopping_product.title ',
        shoppingProductBrand: ' shopping_product.brand ',
        shoppingProductPrice: ' shopping_product.price_micros ',
        shoppingProductCondition: ' shopping_product.condition ',
        shoppingProductAvailability: ' shopping_product.availability ',

        // filters
        networkType: ' segments.ad_network_type ',
        pMaxOnly: ' AND campaign.advertising_channel_type = "PERFORMANCE_MAX" ', // WHERE
        pMaxShop: ' AND campaign.advertising_channel_type IN ("SHOPPING","PERFORMANCE_MAX") ',
        dgOnly: ' AND campaign.advertising_channel_type = "DEMAND_GEN" ',
        dgShop: ' AND campaign.advertising_channel_type IN ("DEMAND_GEN","SHOPPING","PERFORMANCE_MAX") ',
        campLike: ` AND campaign.name LIKE "%${s.campFilter || ''}%" `,
        agFilter: ' AND asset_group_listing_group_filter.type != "SUBDIVISION" ',
        notInter: ' AND segments.asset_interaction_target.interaction_on_this_asset != "TRUE" ',
        impr0: ' AND metrics.impressions > 0 ',
        cost0: ' AND metrics.cost_micros > 0 ',
        order: ' ORDER BY campaign.name ',
    };
}

function checkVersion(userScriptVersion, userSheetVersion, ss) {
    let CONTROL_SHEET = 'https://docs.google.com/spreadsheets/d/16W7nqAGg7LbqykOCdwsGLB93BMUWvU9ZjlVprIPZBtg/' // used to find latest version
    let controlSheet = safeOpenAndShareSpreadsheet(CONTROL_SHEET);
    // get value of named ranges currentScriptVersion & currentSheetVersion
    let latestScriptVersion, latestSheetVersion;
    try {
        latestScriptVersion = controlSheet.getRangeByName('latestScriptVersion').getValue();
        latestSheetVersion = controlSheet.getRangeByName('latestSheetVersion').getValue();
    } catch (e) {
        console.error(`Error fetching current script/sheet version: ${e.message}`);
    }

    // Display messages based on version comparison & write them to userMessage in the main ss
    let userMessage = '';
    try {
        let userMessageRange = ss.getRangeByName('userMessage');

        if (userScriptVersion !== latestScriptVersion || userSheetVersion !== latestSheetVersion) {
            if (userScriptVersion !== latestScriptVersion) {
                userMessage = "Time to update your script. You are using: " + userScriptVersion + ", Latest version is: " + latestScriptVersion + " from here: https://mikerhodes.circle.so/c/script/";
            }
            if (userSheetVersion !== latestSheetVersion) {
                userMessage = "Time to update your sheet. You are using: " + userSheetVersion + ", Latest version is: " + latestSheetVersion;
            }
        } else {
            userMessage = "Great work! You're using the latest versions. Script: " + userScriptVersion + ", Sheet: " + userSheetVersion;
        }
        userMessageRange.setValue(userMessage);
        Logger.log(userMessage);
    } catch (e) {
        Logger.log('Could not find userMessage named range to write version info.');
    }
}

function flattenObject(ob) {
    let toReturn = {};
    let stack = [{
        obj: ob,
        prefix: ''
    }];

    while (stack.length > 0) {
        let {
            obj,
            prefix
        } = stack.pop();
        for (let i in obj) {
            if (obj.hasOwnProperty(i)) {
                let key = prefix ? prefix + '.' + i : i;
                if (typeof obj[i] === 'object' && obj[i] !== null) {
                    stack.push({
                        obj: obj[i],
                        prefix: key
                    });
                } else {
                    toReturn[key] = obj[i];
                }
            }
        }
    }

    return toReturn;
}

function fetchData(q) {
    try {
        let data = [];
        let iterator = AdsApp.search(q, {
            'apiVersion': 'v20'
        });
        while (iterator.hasNext()) {
            let row = flattenObject(iterator.next());
            data.push(row); // Flatten the row data
        }
        return data;
    } catch (error) {
        Logger.log(`Error fetching data for query: ${q}`);
        Logger.log(`Error message: ${error.message}`);
        return null; // Return null to indicate that the data fetch failed
    }
}

function log(ss, startDuration, s, ident) {
    let endDuration = new Date();
    let duration = ((endDuration - startDuration) / 1000).toFixed(0);
    Logger.log(`Script execution time: ${duration} seconds. \nFinished script for ${ident}.`);

    let newRow = [new Date(), duration, s.numberOfDays, s.tCost, s.tRoas, s.brandTerm, ident,
    s.fromDate, s.toDate, s.scriptVersion, s.sheetVersion
    ];
    try {
        ss.getSheetByName('log').appendRow(newRow);
    } catch (e) {
        Logger.log('Could not write to log tab. It might not exist in the template.');
    }
}

function safeOpenAndShareSpreadsheet(url, setAccess = false, newName = null) {
    try {
        // Basic validation
        if (!url) {
            console.error(`URL is empty or undefined: ${url}`);
            return null;
        }

        // Type checking and format validation
        if (typeof url !== 'string') {
            console.error(`Invalid URL type - expected string but got ${typeof url}`);
            return null;
        }

        // Validate Google Sheets URL format
        if (!url.includes('docs.google.com/spreadsheets/d/')) {
            console.error(`Invalid Google Sheets URL format: ${url}`);
            return null;
        }

        // Try to open the spreadsheet
        let ss;
        try {
            ss = SpreadsheetApp.openByUrl(url);
        } catch (error) {
            Logger.log(`Error opening spreadsheet: ${error.message}`);
            Logger.log(`Settings were: ${url}, ${setAccess}, ${newName}`);
            return null;
        }

        // Handle copy if newName is provided
        if (newName) {
            try {
                ss = ss.copy(newName);
            } catch (error) {
                Logger.log(`Error copying spreadsheet: ${error.message}`);
                return null;
            }
        }

        // Handle sharing settings if required
        if (setAccess) {
            try {
                let file = DriveApp.getFileById(ss.getId());

                // Try ANYONE_WITH_LINK first
                try {
                    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.EDIT);
                    Logger.log("Sharing set to ANYONE_WITH_LINK");
                } catch (error) {
                    Logger.log("ANYONE_WITH_LINK failed, trying DOMAIN_WITH_LINK");

                    // If ANYONE_WITH_LINK fails, try DOMAIN_WITH_LINK
                    try {
                        file.setSharing(DriveApp.Access.DOMAIN_WITH_LINK, DriveApp.Permission.EDIT);
                        Logger.log("Sharing set to DOMAIN_WITH_LINK");
                    } catch (error) {
                        Logger.log("DOMAIN_WITH_LINK failed, setting to PRIVATE");

                        // If all else fails, set to PRIVATE
                        try {
                            file.setSharing(DriveApp.Access.PRIVATE, DriveApp.Permission.EDIT);
                            Logger.log("Sharing set to PRIVATE");
                        } catch (error) {
                            Logger.log(`Failed to set any sharing permissions: ${error.message}`);
                        }
                    }
                }
            } catch (error) {
                Logger.log(`Error setting file permissions: ${error.message}`);
                // Continue even if sharing fails - the sheet is still usable
            }
        }

        return ss;

    } catch (error) {
        // Catch any other unexpected errors
        console.error(`Unexpected error in safeOpenAndShareSpreadsheet: ${error.message}`);
        Logger.log(`Full error details: ${error.stack}`);
        return null;
    }
}


/*

DISCLAIMER  -  PLEASE READ CAREFULLY BEFORE USING THIS SCRIPT

Fair Use: This script is provided for the sole use of the entity (business, agency, or individual) to which it is licensed.
While you are encouraged to use and benefit from this script, you must do so within the confines of this agreement.

Copyright: All rights, including copyright, in this script are owned by or licensed to Off Rhodes Pty Ltd t/a Mike Rhodes Ideas.
Reproducing, distributing, or selling any version of this script, whether modified or unmodified, without proper authorization is strictly prohibited.

License Requirement: A separate license must be purchased for each legal entity that wishes to use this script.
For example, if you own multiple businesses or agencies, each business or agency can use this script under one license.
However, if you are part of a holding group or conglomerate with multiple separate entities, each entity must purchase its own license for use.

Code of Honour: This script is offered under a code of honour.
We trust in the integrity of our users to adhere to the terms of this agreement and to do the right thing.
Your honour and professionalism in respecting these terms not only supports the creator but also fosters a community of trust and respect.

Limitations & Liabilities: Off Rhodes Pty Ltd t/a Mike Rhodes Ideas does not guarantee that this script will be error-free
or will meet your specific requirements. We are not responsible for any damages or losses that might arise from using this script.
Always back up your data and test the script in a safe environment before deploying it in a production setting.

The script does not make any changes to your account or data.
It only reads data from your account and writes it to your spreadsheet.
However if you choose to use the data on the ID tab in a supplemental data feed in your GMC account, you do so at your own risk.

By using this script, you acknowledge that you have read, understood, and agree to be bound by the terms of this license agreement.
If you do not agree with these terms, do not use this script.

*/





// Now hit preview (or run) and let's get this party started! Thanks for using this script.


// PS you're awesome!